apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  creationTimestamp: null
  name: virtualservicedenyduplicate
spec:
  crd:
    spec:
      names:
        kind: VirtualserviceDenyDuplicate
  targets:
  - libs:
    - |-
      package lib.common

      default is_gatekeeper = false

      common_labels := [
        {"key": "app.kubernetes.io/name", "allowedRegex": "*"},
        {"key": "app.kubernetes.io/instance", "allowedRegex": "*"},
        {"key": "app.kubernetes.io/version", "allowedRegex": "*"},
        {"key": "app.kubernetes.io/component", "allowedRegex": "*"},
        {"key": "app.kubernetes.io/part-of", "allowedRegex": "*"},
        {"key": "app.kubernetes.io/managed-by", "allowedRegex": "*"},
        {"key": "objectset.rio.cattle.io/hash", "allowedRegex": "*"},
        {"key": "kubernetes.io/metadata.name", "allowedRegex": "*"},
      ]

      has_field(obj, field) {
        not object.get(obj, field, "N_DEFINED") == "N_DEFINED"
      }

      missing_field(obj, field) {
        obj[field] == ""
      }

      missing_field(obj, field) {
        not has_field(obj, field)
      }

      is_gatekeeper {
        has_field(input, "review")
        has_field(input.review, "object")
      }

      is_combined {
        has_field(input[_], "contents")
      }

      resource = input.review.object {
        is_gatekeeper
      }

      resource = input {
        not is_gatekeeper
        not is_combined
      }

      resource = input[0].contents {
        not is_gatekeeper
        is_combined
      }

      parameters = input[1].contents.parameters {
        not is_gatekeeper
        is_combined
      }

      parameters = input.parameters {
        is_gatekeeper
      }

      inventory = input[1].contents.inventory {
        not is_gatekeeper
        is_combined
      }

      inventory = data.inventory {
        is_gatekeeper
      }

      input_containers[c] {
        c := resource.spec.containers[_]
      }

      input_containers[c] {
        c := resource.spec.initContainers[_]
      }

      input_containers[c] {
        c := resource.spec.template.spec.containers[_]
      }

      input_containers[c] {
        c := resource.spec.template.spec.initContainers[_]
      }

      input_volumes[v] {
        v := resource.spec.volumes[_]
      }

      input_volumes[v] {
        v := resource.spec.template.spec.volumes[_]
      }

      contains_label(allowedLabels, key, value) {
        allowedLabels[_].key == key

        # do not match if any allowedRegex is not defined, or is an empty string
        allowedLabels[_].allowedRegex != ""
        re_match(allowedLabels[_].allowedRegex, value)
      } else = false

      not_contains_label(labels, key, value) {
        not contains_label(labels, key, value)
      }

      is_common_label(key, value) {
        # as of now it is just equality but in future it can be regex
        common_labels[_].key == key
      } else = false

      not_common_label(key, value) {
        not is_common_label(key, value)
      }

      contains_prefix(allowedPrefixes, value) {
        # do not match if any allowedRegex is not defined, or is an empty string
        allowedPrefixes[_] != ""
        startswith(value, allowedPrefixes[_])
      } else = false

      not_contains_prefix(allowedPrefixes, value) {
        not contains_prefix(allowedPrefixes, value)
      }

      contains_array_elem(array, elem) {
        array[_] == elem
      } else = false

      not_contains_array_elem(array, elem) {
        not contains_array_elem(array, elem)
      }

      identical_k8s_objects(obj1, obj2) {
        has_field(obj1.metadata, "namespace")
        has_field(obj2.metadata, "namespace")
        obj1.metadata.namespace == obj2.metadata.namespace
        obj1.metadata.name == obj2.metadata.name
        obj1.kind == obj2.kind
        obj1.apiVersion == obj2.apiVersion
      }

      identical_k8s_objects(obj1, obj2) {
        missing_field(obj1.metadata, "namespace")
        missing_field(obj2.metadata, "namespace")
        obj1.metadata.name == obj2.metadata.name
        obj1.kind == obj2.kind
        obj1.apiVersion == obj2.apiVersion
      }
    rego: |-
      package virtualservice_deny_duplicate

      import data.lib.common as common_lib

      violation[{"msg": msg, "details": {}}] {
        common_lib.resource.kind == "VirtualService"
        re_match("^networking.istio.io/.+$", common_lib.resource.apiVersion)

        other_virtualservice := common_lib.inventory.namespace[_][gv].VirtualService[name]

        # lets match all the group versions (v1beta1,v1,..)
        re_match("^networking.istio.io/.+$", gv)

        # first check if this is the same VirtualService object
        not common_lib.identical_k8s_objects(common_lib.resource, other_virtualservice)

        # check that the host is not not defined in any of the vc defined in the cluster
        some i
        common_lib.contains_array_elem(other_virtualservice.spec.hosts, common_lib.resource.spec.hosts[i])

        msg := sprintf("VirtualService host <%v> conflicts with a defined host in an existing VirtualService: <%v/%v>", [common_lib.resource.spec.hosts[i], other_virtualservice.metadata.namespace, other_virtualservice.metadata.name])
      }
    target: admission.k8s.gatekeeper.sh
status: {}
