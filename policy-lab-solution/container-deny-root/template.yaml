apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  creationTimestamp: null
  name: containerdenyroot
spec:
  crd:
    spec:
      names:
        kind: ContainerDenyRoot
  targets:
  - libs:
    - |-
      package lib.common

      default is_gatekeeper = false

      common_labels := [
        {"key": "app.kubernetes.io/name", "allowedRegex": "*"},
        {"key": "app.kubernetes.io/instance", "allowedRegex": "*"},
        {"key": "app.kubernetes.io/version", "allowedRegex": "*"},
        {"key": "app.kubernetes.io/component", "allowedRegex": "*"},
        {"key": "app.kubernetes.io/part-of", "allowedRegex": "*"},
        {"key": "app.kubernetes.io/managed-by", "allowedRegex": "*"},
        {"key": "objectset.rio.cattle.io/hash", "allowedRegex": "*"},
        {"key": "kubernetes.io/metadata.name", "allowedRegex": "*"},
      ]

      has_field(obj, field) {
        not object.get(obj, field, "N_DEFINED") == "N_DEFINED"
      }

      missing_field(obj, field) {
        obj[field] == ""
      }

      missing_field(obj, field) {
        not has_field(obj, field)
      }

      is_gatekeeper {
        has_field(input, "review")
        has_field(input.review, "object")
      }

      is_combined {
        has_field(input[_], "contents")
      }

      resource = input.review.object {
        is_gatekeeper
      }

      resource = input {
        not is_gatekeeper
        not is_combined
      }

      resource = input[0].contents {
        not is_gatekeeper
        is_combined
      }

      parameters = input[1].contents.parameters {
        not is_gatekeeper
        is_combined
      }

      parameters = input.parameters {
        is_gatekeeper
      }

      inventory = input[1].contents.inventory {
        not is_gatekeeper
        is_combined
      }

      inventory = data.inventory {
        is_gatekeeper
      }

      input_containers[c] {
        c := resource.spec.containers[_]
      }

      input_containers[c] {
        c := resource.spec.initContainers[_]
      }

      input_containers[c] {
        c := resource.spec.template.spec.containers[_]
      }

      input_containers[c] {
        c := resource.spec.template.spec.initContainers[_]
      }

      input_volumes[v] {
        v := resource.spec.volumes[_]
      }

      input_volumes[v] {
        v := resource.spec.template.spec.volumes[_]
      }

      contains_label(allowedLabels, key, value) {
        allowedLabels[_].key == key

        # do not match if any allowedRegex is not defined, or is an empty string
        allowedLabels[_].allowedRegex != ""
        re_match(allowedLabels[_].allowedRegex, value)
      } else = false

      not_contains_label(labels, key, value) {
        not contains_label(labels, key, value)
      }

      is_common_label(key, value) {
        # as of now it is just equality but in future it can be regex
        common_labels[_].key == key
      } else = false

      not_common_label(key, value) {
        not is_common_label(key, value)
      }

      has_key(obj, key) {
        _ = obj[key]
      }

      not_has_key(obj, key) {
        not has_key(obj, key)
      }

      contains_prefix(allowedPrefixes, value) {
        # do not match if any allowedRegex is not defined, or is an empty string
        allowedPrefixes[_] != ""
        startswith(value, allowedPrefixes[_])
      } else = false

      not_contains_prefix(allowedPrefixes, value) {
        not contains_prefix(allowedPrefixes, value)
      }

      contains_array_elem(array, elem) {
        array[_] == elem
      } else = false

      not_contains_array_elem(array, elem) {
        not contains_array_elem(array, elem)
      }
    rego: |-
      package container_deny_root

      import data.lib.common as common_lib

      default runAsNonRoot_not_exists = true

      default runAsUser_not_exists = true

      default runAsGroup_not_exists = true

      container_root_user {
        c := common_lib.input_containers[_]
        common_lib.not_has_key(c.securityContext, "runAsNonRoot")
        common_lib.not_has_key(c.securityContext, "runAsUser")
        common_lib.not_has_key(c.securityContext, "runAsGroup")
      }

      container_root_user {
        c := common_lib.input_containers[_]
        c.securityContext.runAsNonRoot == false
      }

      container_root_user {
        c := common_lib.input_containers[_]
        c.securityContext.runAsUser == 0
      }

      container_root_user {
        c := common_lib.input_containers[_]
        c.securityContext.runAsGroup == 0
      }

      violation[{"msg": msg, "details": {}}] {
        c := common_lib.input_containers[_]
        container_root_user

        msg := sprintf("Running container as root is not allowed, ensure you fix your securityContext %v", [c.securityContext])
      }
    target: admission.k8s.gatekeeper.sh
status: {}
